변수
let a=15;
변경 가능한 데이터 저장
let 중복이름x var 중복이름o > let 권장

상수
const a=1;
변경 불가능한 데이터 저장
선언 동시에 초기화 필수

규칙
별도 라이브러리 객체 변수명 > $
camelExpression / PascalExpression / snake_expression

자료형
primitive (1변수1값)
number / 숫자 : infinity, NaN > 안전한 연산 가능
string / 문자 : 템플릿 리터럴 - `` 이용하여 ${변수명} 삽입 > 동적 문자열 생성 가능
boolean, null, undefined / 아무값X> null, 아무값할당x > undefined

object : object (array, function, RegExp)

형변환
묵시적 형변환 : js엔진이 스스로
명시적 형변환 : 내장함수 이용
숫자형으로 / 
Number()
parseInt(변환문자열, 진수) 숫자,문자 포함>숫자만 추출 / 첫번째 숫자x문자o>NaN

문자열로
String()

불리언으로
Boolean() 0>false, else>true로 +truthy&falsy 규칙 (2장)

연산자
대입 = 산술 + - * / % 복합대입 += 
증감 : 변수++ ++변수 
논리 : or || and && not !
비교 : ==(값 비교)!= ===(자료형까지 비교)!== > < >= <=
null 병합 연산자 :  변수a??변수b - 둘다확정o 왼쪽값 반환, 왼쪽값 확정x>오른쪽값 반환 (실무 기본값 사용)
동적 타이핑
변수 저장 데이터 따라 변수 자료형 함께 변경됨 > typeof로 확인 +조건문
삼항조건 : a?b:c a 조건이 참이면 b, 거짓이면 c 수행

조건문
if문 if (조건식) {} else if (조건식) {} else {} 조건따라 실행문 복잡할 때
switch문 switch 변수 { case a : { A; break; } case b: … defalut : { D; } } 조건 개수 많을떄

반복문
for문 for (변수 초기화; 조건식; 증감식) {} / if문 삽입하여 break>중단, continue>건너뜀o

함수
코드를 블록으로 묶어 구조적 안정 & 반복 사용 가능
선언 function 함수명 (매개변수) { return 변수or값; }
호출 함수명(인수);
매개변수, 인수, 반환값 개념

중첩 함수 - 함수 내부 함수
함수 호이스팅 - 선언 전에 호출 가능한 js만의 특징
함수 표현식 - js에서 함수->데이터
let 함수명 = function () {} (익명함수 선언 동시에 변수 저장)(선언x값o>호이스팅X)
function 함수명 () {}…let 변수명=함수명; (선언된 함수 변수에 저장)
콜백 함수 – 인수로 함수를 받아서 함수내에서 다른함수 호출
function 원함수명(매개변수, callback) { callback(); }
function 함수명() {}
원함수명(인수, 함수명); 
+repeat(5, double);로 2 4 6 8 10 출력하기
익명 함수로도 사용가능 – 1변수에 할당하기 2함수명 자리에 직접 집어넣기
화살표 함수 – 간결한 익명 함수 let 함수명 = 매개변수 => 반환값; (많으면 =>{}) 콜백 인수로도 가능?

스코프
전역 스코프 – 전역 변수
지역 스코프 ( 블록 스코프 / 함수 스코프 ) – 지역 변수

객체
리터럴 생성 let 객체명 = { 키(프로퍼티명) : 값(프로퍼티 값) }; (const o)
생성자 생성 let 객체명 = new Object();
호출 객체명.프로퍼티명 / 객체명[프로퍼티명] (유동적인 값)
“프로퍼티명” in 객체명 > 존재 체크
메서드 : 값이 함수인 프로퍼티
{}안에 메서드명 : function () { }
호출 객체명.메서드명() / Object.메서드명(객체명)

배열
리터럴 생성 let 변수명 = new Array();
생성자 생성 let 변수명 = [ 1, “a”, null ];

truthy & falsy : 상황 따라 참/거짓
f => undefined, null, 0, NaN, “”, -0, 0n / t=>그외
+변수가 공백인지 / 0, -0, NaN인지 확인하는 if문

short-circuit
&& : 왼쪽 falsy>계산x +property notfound 에러방지
|| : 왼쪽 truthy>계산x

객체로서의 배열과 함수
배열 – 프로퍼티 (length…), 메서드 (push()…) 있음
함수 – 프로퍼티 (name…)

객체 데이터 저장
primitive : 변수->값
object : 변수->주소->값 >>> 참조!

참조에 의한 비교
=== > 같은 값 참조하는 객체라도 서로 !=

반복문 응용
length 프로퍼티 이용 > 변동되는 배열 길이로 인덱스
for (let 변수명 of 배열명) > 배열 값 순회 +이걸로 객체의 키와 값을 모두 출력
Object.keys 객체 메서드 > Object.keys(객체명) 프로퍼티의 키를 배열로 반환
Object.values 객체 메서드 ,,
for (let 변수명 in 객체명) > 객체의 프로퍼티 key 순회
	